<html>

<body>
    <script>
        /*
        ▣ 입력예제 1                                   
        5
        87 89 92 100 76
        ▣ 출력예제 1
        4 3 2 1 5

        */
        
        
        function solution(arr, length){
            // 내가 작성한 답
            /*
            - 📌 문제 이해: 각 [i][j]의 숫자 값이 상, 하, 좌, 우의 값보다 큰지 판단하여 
            해당하는 갯수를 return한다. 
            - 🔍 풀이 방식 파악: 
            봉우리 체크 조건 ? [i][j]값이 0보다 큰가? 
            상하좌우 체크 조건 ? 
            (1) 상,하,좌,우 의 인덱스가 0보다 크고 length의 범위 내에 있어야함
                    

            이중포문으로 만들고, 상하좌우를 구하는 dx, dy로 조건문 만들어서 통과하는 값만 answer++
            
            - 🧠 풀이 패턴 기억: 
            dx, dy 로 상하좌우 탐색, 해당하는 조건을 잘 구현하는 것이 관점
            (이 패턴은 나중에 길 찾기 문제에서도 많이 나오는 패턴이라 알고 있어야함)
            */
            
            // -- 내가 작성한 답
            const dx = [-1,1,0,0];
            const dy = [0,0,-1,1];
            
            for(let i =0; i< length; i++){
                for(let j =0; i<length; j++){
                    if(arr[i][j] > 0){
                        // for문으로 돌리려고 했으나 기억이 안남.. 그냥 다 조건 줘서 true인지 체크
                        /*
                            for(let k =0; k<4; k++){
                                // 상 하 좌 우 
                                // i-1, i+1, i, i
                                const tx = i+dx[k];
                                
                                // j,j,j-1, j+1
                                const ty = j+dy[k];
                                if( tx>0 && ty>0 
                                    && tx <= n && ty <=n 
                                    && arr[tx][ty] < arr[i][j]
                                ){
                                }  
                            }
                        */
                        if(arr[i-1][j] < arr[i] && 
                            arr[i+1][j] < arr[i] &&
                            arr[i][j-1] < arr[i] && 
                            arr[i][j+1] < arr[i]
                        ){
                            // .. 이것도 아닌 것 같다..
                        }

                    }
                }
            }
            
            // 강의
            /*
            - 📌 문제 이해: 원소들의 외곽 가장자리는 0으로 초기화 했으니까 
            외곽 원소를 체크할때 (1,1)이라면 상,좌는 체크 안해도 된다.
            - 🔍 풀이 방식 파악: 
            dx = [-1,1,0,0]
            dy = [0,0,-1,1] 
            tx = i+dx[i]
            ty = j+dy[j]
            숫자가 하나라도 크면 봉우리가 아니다~ 하고 지나간다. 
            
            - 🧠 풀이 패턴 기억: 
            하나라도 크면 = 하나라도 크다면 false로 flag를 바꾼다. 
            */
            
            // ** 내가 다시 풀기
            for(let i =0; i<length; i++){
                for(let j=0; j<length; j++){
                    let flag = 1;
                    for(k = 0; k<4; k++){
                        const nx = i + dx[k];
                        const ny = j + dx[k];
                        // 하나라도 조건 통과 못하면(=상하좌우값이 하나라도 크다면) 0으로 바꾼다. 
                        // 단 nx, ny의 조건도 추가해줘야한다.
                        if(
                        nx>=0 && nx < n &&
                        ny>=0 && ny < n &&    
                        arr[nx][ny] >= arr[i][j]){
                            flag = false;
                            break;
                        }
                    }
                    if(flag){
                        // 상 하 좌 우 지점에 일치하는 값이 하나도 없었다.
                        answer++;
                    }

                }
            }
            


            // 강의 
            
            // 나의 코멘트 
            /*
            상하좌우 접근방식까지는 좋았는데, 
            '하나라도' 에서 반복문까지 빠져나오는 혼란을 겪었다. 
            생각하는 것보다 심플하게 생각하면 쉬운 문제들일지도? 
            flag변수가 핵심이었다!
            */
        }

        console.log(solution([87,89, 92, 100, 76]))
    </script>
</body>

</html>