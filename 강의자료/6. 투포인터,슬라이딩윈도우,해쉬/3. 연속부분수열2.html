<html>

<body>
    <script>
        /*
        ▣ 입력예제 1                                   
        
        ▣ 출력예제 1
         
        */
        
        
        function solution(arr, M){
            // 내가 작성한 답
            /*
            - 📌 문제 이해: 
            이번엔 배열이 한개군. 
            start, end로 arr을 탐색하면서 
            값이 크면-> end--
            값이 작으면 -> start
            - 🔍 풀이 방식 파악: 
            하나의 배열에서 두개의 포인터 사용해서 정답 좁혀가기
            - 🧠 풀이 패턴 기억: 
            */
            
            // -- 내가 작성한 답
                
            
            // 강의
            /*
            - 📌 문제 이해: 
            
            - 🧠 풀이 패턴 기억: 
            for문으로 rt를 계속 이동해가면서 i의 합이 M과 같은지 탐색
            만약 M보다 커졌다면
            lt인덱스의 값을 sum에서 빼준다. 
            이때 한번만 몇번 얼만큼 빼줘야하냐면 
            sum <=m 일때까지 빼준다. 여기서 while
            그리고 sum이 M과 같거나 작아졌을때 rt인덱스를 포함하는 원소의 갯수를 카운팅해준다. 
            rt인덱스인 원소를 포함하는 부분 수열 = rt-lt+1 개.
            
            * for문으로 rt값을 늘려가기 
            * lt가 움직여야하는 조건 추가하기 while(sum > m) (M보다 sum이 크다면 앞에서부터 빼준다. 작아질때까지)
            * 해당 인수를 포함하는 부분수열의 갯수 구하는 공식 rt-lt+1
            * if(start<=end) 이건 왜 안쓰이지? 언제쓰이는거지??? 
            */
            
            // ** 내가 다시 풀기
            
            
            /*
            
            */
            

            
            // 강의 
            let answer = 0, sum = 0, lt=0;
            for(let rt = 0; rt<arr.length; rt++){
                sum+=arr[rt];
                // 추가했는데 m보다 크다면 
                if(sum > m){
                    sum -=arr[lt++];
                }
                answer += (rt-lt+1)
            }
        }

        console.log(solution([1,3,1,2,3], 5))
    </script>
</body>

</html>