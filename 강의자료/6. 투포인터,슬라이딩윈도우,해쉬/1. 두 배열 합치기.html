<html>

<body>
    <script>
        /*
        ▣ 입력예제 1                                   
        
        ▣ 출력예제 1
         
        */
        
        
        function solution(arr){
            // 내가 작성한 답
            /*
            - 📌 문제 이해: 두 배열 합쳐서 sort?
            - 🔍 풀이 방식 파악: 
            - 🧠 풀이 패턴 기억: 
            */
            
            // -- 내가 작성한 답
            
            // 강의
            /*
            - 📌 문제 이해: 
            합쳐서 sort 하면 nlogn
            투포인터로 p1, p2로 for문 한번만 돌면 탐색할 수 있다.
            그럼 총 시간 복잡도는 n+m
            - 🔍 풀이 방식 파악: 
            p1 = p2 =0 으로 초기화 
            arr1[p1] arr2[p2] 둘 중 작은 것을 answer에 push
            값이 들어간 포인터는 포인터를 ++
            둘중 하나가 멈추면 비교를 멈추고, 남은 배열의 나머지 원소들을 다 push

            - 🧠 풀이 패턴 기억: 
            */
            
            // ** 내가 다시 풀기
            /*
            arr1의 포인터 p1, arr2의 포인터 p2
            로 더 작은 값을 넣어주고 포인터를 ++
            둘 중 하나의 원소가 끝나서 while문을 나오면, 남은 원소를 모두 push
            */
            let n = arr1.length;
            let m = arr2.length;
            let p1 = p2 = 0;
            while(p1 < n && p2 < m){
                if(arr1[p1] < arr2[p2]){
                    answer.push(arr1[p1])
                    p1++;
                }else{
                    answer.push(arr2[p2])
                    p2++;
                }
            }

            if(p1<n){
                answer.push(arr1[p1])
                p1++;
            }

            if(p2<n){
                answer.push(arr2[p2])
                p2++;
            }
            return answer;

             // 강의 
            let n = arr1.length;
            let m = arr2.length;
            let p1 = p2 = 0;
            while(p1<n && p2 <m){
                // 누군가 하나가 끝나면 멈춘다. 
                if(arr1[p1] <= arr2[p2]){
                    // arr1[p1]을 넣고, p1 을 ++
                    answer.push(arr1[p1++])
                }else{
                    answer.push(arr2[p2++])
                }
                
            }
            // 남은 원소를 넣어야됨
            // p1의 원소가 남았다면
            while(p1<n){
                answer.push(arr1[p1++])
            }
            while(p2<m){
                answer.push(arr2[p2++])
            }
            return answer;

            // [나의 코멘트]
            /*
            두 배열의 원소를 비교할때 각각의 포인터를 쓰는 방법이 있구나
            비교한 포인터의 값을 ++ 해준다. 
            
            */
        }

        console.log(solution([130,135,148,140,145,150,150,153 ]))
    </script>
</body>

</html>