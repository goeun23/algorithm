<html>

<body>
    <script>
        /*
        ▣ 입력예제 1                                   
        
        ▣ 출력예제 1
         
        */
        
        
        function solution(arr){
            // 내가 작성한 답
            /*
            - 📌 문제 이해: 
            M번의 시험 성적 등수(arr의 갯수)
            N:학생 수 (4명) 
                1회     2회     3회
            1등 3번     4번     3번
            2등 4번     3번     1번
            3등 1번     2번     4번
            4등 2번     1번     2번
            ---------------------------
            1등 횟수 : 
                1위 : 3번
                2위 : 4번
            2등 횟수 :
                1위 : 4, 3, 1번
            3등 횟수 :
                1위 : 1, 2, 4 번
            4등 횟수 : 
                1위 : 2번
                2위 : 1번
            ---------------------------
            (3번, 1번) (3번, 2번) (4번, 2번) 
            A번 학생은 B학생보다 M번의 시험을 모두 잘 봄
            ----------------------------
            1번 :(0,1,1,1)
                1등 : 0회 
                2등 : 1회
                3등 : 1회
                4등 : 1회
            2번 :(0,0,1,2)
                1등 : 0회
                2등 : 0회
                3등 : 1회
                4등 : 2회
            3번 :(2,1,0,0)
                1등 : 2번
                2등 : 1번
                3등 : 0회
                4등 : 1회
            4번 :(1,1,1,0)
                1등 : 1회
                2등 : 1회
                3등 : 1회
                4등 : 0회


            - 🔍 풀이 방식 파악: 도저히 감이 안옴.. 강의에서 어떻게 푸는지 보고 오자.. 
            
            - 🧠 풀이 패턴 기억: 
            
            */
            
            // -- 내가 작성한 답           
            


            // 강의
            /*
            - 📌 문제 이해: 
            어려웠을 문제.. 네네 어려워요;; 
            이거는 그런 주어진대로 푸는 문제가 아니다.. 
            완전탐색 for문으로 돌리는. 아주 대표적인 문제 
            총 경우의 수를 다 만들어서 확인해봐야한다. 
            4명이라면 ? 멘토가 4명이라면, 멘티가 될 수 있는 경우 4 4*4
            i= 1, 4까지,
            j= 1, 4까지, 
            총 16가지를 다 확인해봐야겠다. 이게 블루투포스 
            i는 멘토, j는 멘티 
            (i, j) i번 학생이 3번의 시험에서 모두 j를 앞서야 한다. 
            이 안에서 또 for문이 돌아야죠.
            N번의 시험성적에서 i, j가 몇등을 했는지도 for문을 돌아야함 
            총 4중 포문이다. 
            test[k][s] == i (N번의 시험 중, i의 등수를 찾으면, pi = s)
            s = i의 등수
            test[k][s] == j
            s = j의 등수
            - 🔍 풀이 방식 파악: 
            4중 포문을 돌린다. 
            i : 멘토, j: 멘티, k : 시험의 회차 j : 시험의 등수
            [k][s] == i -> k회차의 i의 등수
                pi = s;
            [k][s] == j -> k회차의 j의 등수
                pj = s;
            if(pi < pj){
                answer++; -> 이렇게 모든 학생, 모든 회차, 모든 등수를 탐색하면서 조건이 맞으면 count를 ++
            }
            - 🧠 풀이 패턴 기억: 
            
            */
            
            // ** 내가 다시 풀기
            var answer =0;
            
            for(let i =0; i< N; i++){ // 멘토
                for(let j =0; j < N; j++){ // 멘티
                    for(let k = 0; k < M; k++){ // 회차
                        for(let s = 0; s < M; s++){ // 등수
                            let pi = 0, pj = 0;
                            if(arr[k][s] == i){ // 배열[회차][등수] == i
                                pi = s;
                            }
                            if(arr[k][s] == j){ // 배열[회차][등수] == j
                                pj = s;
                            }   
                        }
                        if(pi < pj){
                            answer++;
                        }
                    }
                }
            }
            return answer;

            // 강의의 풀이 
            var answer =0;
            var cnt =0;
            for(let i =0; i< N; i++){ // 멘토
                for(let j =0; j < N; j++){ // 멘티
                    let cnt = 0;
                    for(let k = 0; k < M; k++){ // 회차
                        for(let s = 0; s < M; s++){ // 등수
                            // 등수 찾는 탐색
                            let pi = 0, pj = 0;
                            if(arr[k][s] == i){ // 배열[회차][등수] == i
                                pi = s;
                            }
                            if(arr[k][s] == j){ // 배열[회차][등수] == j
                                pj = s;
                            }   
                        }
                        // 등수 비교
                        if(pi < pj) {
                            cnt++;
                        }
                    }
                    // 모든 테스트에서 통과했다면 = 탐색의 횟수가 answer와 같다면
                    if(cnt == M){
                        answer++;
                    }
                }
            }
            return answer;
            
            /*
            [나의 코멘트]
            완전탐색은 모든 조건을 다 따져봐야할 때 탐색하는 방법이다.(블루투포스)
            이걸 구현하기 위해서는 반복문으로 걸어야할 i, j, k, s를 명확히 알아야 한다. 
            그리고 i, j, k, s를 몇 번, 뭘 기준으로 돌릴지 잡고
            조건을 확인한다음. for문 한겹씩 바깥에서 구한 값으로 조건을 따져본다. 
            * 원칙대로 풀면 4중 포문도 나올수가 있구나.
            기존에 1등 횟수, 2등 횟수 등은 잘못된 접근방식이었다. 
            완전탐색은 생각보다 직관적(아, 이건 다 따져봐야하네!)하면 완전 탐색하면 된다. 
            */
        }

        console.log(solution([32,55,62,20,250,370,200,30,100, 910 ]))
    </script>
</body>

</html>