<html>

<body>
    <script>
        /*
        ▣ 입력예제 1                                   
        
        ▣ 출력예제 1
         
        */
        
        
        function solution(arr){
            // 내가 작성한 답
            /*
            - 📌 문제 이해: 문자열 뒤집기+ 솟수 구하기
            - 🔍 풀이 방식 파악: 
            문자열 뒤집기는 reverse()를 사용하고, 솟수인지 판별한다..            
            - 🧠 풀이 패턴 기억: 
            솟수는 어떻게 구할까
            */
            
            // -- 내가 작성한 답           
            /*
            let answer =[];
            for(let x of arr){
                // string -> reverse -> to Number
                let num = String(x).split('').reverse().join('');
                num = Number(num);
                while()
                console.log(num)
            }
            */


            // 강의
            /*
            - 📌 문제 이해: 
            내가 이해한 것과 같다.
            - 🔍 풀이 방식 파악: 
            1. while문이 x가 0이 아닐때까지 돈다. 
            2. while문 안에서 뒤에 자리수부터 떼네어서 res를 갱신
            2-1. 맨 마지막 숫자 = x % 10;
            2-2. 뒤집은 숫자를 담을 변수 res의 값을 갱신 (res = res*10+t)
            2-3. while문을 계속해서 돌 x 값 갱신 (x = parseInt(x/10))
            3. res가 솟수 인지 판별하는 함수 체크(isPrime)
            3-1. 1은 솟수가 아님. if(num === 1) return;
            3-2. 솟수는 1과 자기 자신만을 약수로 가지기 때문에 2부터 num까지 약수가 있다면 return false,
            3-3. 반목문에서 false로 함수를 나가지 않았다면 솟수가 맞음. return true;
            
            - 🧠 풀이 패턴 기억: 
            * reverse()를 사용하지 않고 숫자를 뒤집는 방법
            * 솟수인지 판별하는 방법
            * 함수를 두 개로 나누어 판별
            */
            
            // ** 내가 다시 풀기
            for(let x of arr){
                // 2. 숫자 뒤집기
                while(x){ // x가 0이 아니면
                    let res = 0; // 뒤집은 값을 담을 변수 
                    // 2-1. 맨 마지막 자릿수를 가져오기(=10으로 나눈 나머지)
                    let t = x % 10; 
                    // 2-2. res를 업데이트
                    res = res*10 + t; // 나머지 값에 10을 곱하면 몫(res*10)이 되고, 몫에 나머지를 더해서(+t) 값을 뒤에자리부터 하나씩 떼서 갱신
                    // 2-3. 계속 나눠서 뒤집어야할 원래 변수값을 업데이트
                    x = parseInt(x/10);

                    /*
                    [숫자 뒤집기 반목문]
                    x = 32
                        t = x % 10
                        (t = 32 % 10 = 2)
                        res = res * 10 + t;
                        (res = 0 * 10 + 2 = 2;)
                        x = parseInt(x/10);
                        (x = parseInt(32/10) = 3)
                    ---------------------------------
                    x = 3
                        t = 3 % 10 = 3;
                        res = 2 * 10 + 3 = 23
                        x = parseInt(3/10) = 0;
                    ---------------------------------
                    x = 0 반목문 종료 
                    32를 뒤집은 숫자 : 23
                    */
                }
                // 3. x == 0인 상태로 모든 뒤집기가 끝난 상태
                // 3-1. 숫자가 솟수인지 판별하는 함수 태워 체크 
                if(isPrime(res)){
                    answer.push(res)// 뒤집어진 그 숫자를 return하기로 함.
                }
            }

            // 3 솟수인지 판별. 
            function isPrime(num){
                // 1. 1은 솟수가 아니다. 
                if(num === 1) return false;
                // 약수는 뒤집어도 같은 값이 나오기 때문에 약수가 있는지 판별하려면 num의 절반값 혹은 제곱근 까지만 체크해줘도 된다.
                // 반복문을 금방 빠져나오기 위함
                
                //for(let i = 2; i< num; i++){ 
                for(let i =2; i < parseInt(Math.sqrt(num)); i++){
                    if(num % i ===0){
                        // 2부터 num의 제곱근까지 나눠떨어지는 값이 있다면 = 약수가 있다면
                        return false; // 솟수가 아니다. 
                    }
                }
                // for문을 돌았는데도 약수가 없다면
                return true;
            }

            // 문제에서 찾는 배열을 return
            return answer;
            // 강의 
            
            /*
            [나의 코멘트]
            * reverse() 하지말고 %10 하여 나머지로 값을 가져오는 방법이 정석이다. 
            * ㄴ 10으로 나눈 나머지를 reverse의 숫자로 갖되, 계속 나머지를 구할 변수를 업데이트하는 공식을 이해해야함(res = res*10+t)
            * 약수는 제곱근까지만 돌려도 된다. (끝까지 돌려도 뒤집은 약수가 나오기 때문)
            * 1은 솟수가 아니다
            * 2부터 돌리는 이유는 num은 무조건 1과 자기 자신을 원소로 갖기 때문
            *  ㄴ 처음에 생각했을때 1부터 돌려서 약수가 2인 길이를 체크하려고 했는데, 이 방법보다 이게 더 확실하고 안전한 방법 같다
            * 어떤 수든 자기 자신을 제외한 가장 큰 약수는 자기 자신의 절반값이다. (16의 약수중 가장 큰 값은 : 2*8, 8 임(8은 16/2)
            */
        }

        console.log(solution([32,55,62,20,250,370,200,30,100, 910 ]))
    </script>
</body>

</html>